// Code generated by counterfeiter. DO NOT EDIT.
package brokerstorefakes

import (
	"sync"

	"code.cloudfoundry.org/lager"
	"code.cloudfoundry.org/service-broker-store/brokerstore"
	"github.com/pivotal-cf/brokerapi"
)

type FakeStore struct {
	RetrieveInstanceDetailsStub        func(id string) (brokerstore.ServiceInstance, error)
	retrieveInstanceDetailsMutex       sync.RWMutex
	retrieveInstanceDetailsArgsForCall []struct {
		id string
	}
	retrieveInstanceDetailsReturns struct {
		result1 brokerstore.ServiceInstance
		result2 error
	}
	retrieveInstanceDetailsReturnsOnCall map[int]struct {
		result1 brokerstore.ServiceInstance
		result2 error
	}
	RetrieveBindingDetailsStub        func(id string) (brokerapi.BindDetails, error)
	retrieveBindingDetailsMutex       sync.RWMutex
	retrieveBindingDetailsArgsForCall []struct {
		id string
	}
	retrieveBindingDetailsReturns struct {
		result1 brokerapi.BindDetails
		result2 error
	}
	retrieveBindingDetailsReturnsOnCall map[int]struct {
		result1 brokerapi.BindDetails
		result2 error
	}
	RetrieveAllInstanceDetailsStub        func() (map[string]brokerstore.ServiceInstance, error)
	retrieveAllInstanceDetailsMutex       sync.RWMutex
	retrieveAllInstanceDetailsArgsForCall []struct{}
	retrieveAllInstanceDetailsReturns     struct {
		result1 map[string]brokerstore.ServiceInstance
		result2 error
	}
	retrieveAllInstanceDetailsReturnsOnCall map[int]struct {
		result1 map[string]brokerstore.ServiceInstance
		result2 error
	}
	RetrieveAllBindingDetailsStub        func() (map[string]brokerapi.BindDetails, error)
	retrieveAllBindingDetailsMutex       sync.RWMutex
	retrieveAllBindingDetailsArgsForCall []struct{}
	retrieveAllBindingDetailsReturns     struct {
		result1 map[string]brokerapi.BindDetails
		result2 error
	}
	retrieveAllBindingDetailsReturnsOnCall map[int]struct {
		result1 map[string]brokerapi.BindDetails
		result2 error
	}
	CreateInstanceDetailsStub        func(id string, details brokerstore.ServiceInstance) error
	createInstanceDetailsMutex       sync.RWMutex
	createInstanceDetailsArgsForCall []struct {
		id      string
		details brokerstore.ServiceInstance
	}
	createInstanceDetailsReturns struct {
		result1 error
	}
	createInstanceDetailsReturnsOnCall map[int]struct {
		result1 error
	}
	CreateBindingDetailsStub        func(id string, details brokerapi.BindDetails) error
	createBindingDetailsMutex       sync.RWMutex
	createBindingDetailsArgsForCall []struct {
		id      string
		details brokerapi.BindDetails
	}
	createBindingDetailsReturns struct {
		result1 error
	}
	createBindingDetailsReturnsOnCall map[int]struct {
		result1 error
	}
	DeleteInstanceDetailsStub        func(id string) error
	deleteInstanceDetailsMutex       sync.RWMutex
	deleteInstanceDetailsArgsForCall []struct {
		id string
	}
	deleteInstanceDetailsReturns struct {
		result1 error
	}
	deleteInstanceDetailsReturnsOnCall map[int]struct {
		result1 error
	}
	DeleteBindingDetailsStub        func(id string) error
	deleteBindingDetailsMutex       sync.RWMutex
	deleteBindingDetailsArgsForCall []struct {
		id string
	}
	deleteBindingDetailsReturns struct {
		result1 error
	}
	deleteBindingDetailsReturnsOnCall map[int]struct {
		result1 error
	}
	IsInstanceConflictStub        func(id string, details brokerstore.ServiceInstance) bool
	isInstanceConflictMutex       sync.RWMutex
	isInstanceConflictArgsForCall []struct {
		id      string
		details brokerstore.ServiceInstance
	}
	isInstanceConflictReturns struct {
		result1 bool
	}
	isInstanceConflictReturnsOnCall map[int]struct {
		result1 bool
	}
	IsBindingConflictStub        func(id string, details brokerapi.BindDetails) bool
	isBindingConflictMutex       sync.RWMutex
	isBindingConflictArgsForCall []struct {
		id      string
		details brokerapi.BindDetails
	}
	isBindingConflictReturns struct {
		result1 bool
	}
	isBindingConflictReturnsOnCall map[int]struct {
		result1 bool
	}
	RestoreStub        func(logger lager.Logger) error
	restoreMutex       sync.RWMutex
	restoreArgsForCall []struct {
		logger lager.Logger
	}
	restoreReturns struct {
		result1 error
	}
	restoreReturnsOnCall map[int]struct {
		result1 error
	}
	SaveStub        func(logger lager.Logger) error
	saveMutex       sync.RWMutex
	saveArgsForCall []struct {
		logger lager.Logger
	}
	saveReturns struct {
		result1 error
	}
	saveReturnsOnCall map[int]struct {
		result1 error
	}
	CleanupStub        func() error
	cleanupMutex       sync.RWMutex
	cleanupArgsForCall []struct{}
	cleanupReturns     struct {
		result1 error
	}
	cleanupReturnsOnCall map[int]struct {
		result1 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeStore) RetrieveInstanceDetails(id string) (brokerstore.ServiceInstance, error) {
	fake.retrieveInstanceDetailsMutex.Lock()
	ret, specificReturn := fake.retrieveInstanceDetailsReturnsOnCall[len(fake.retrieveInstanceDetailsArgsForCall)]
	fake.retrieveInstanceDetailsArgsForCall = append(fake.retrieveInstanceDetailsArgsForCall, struct {
		id string
	}{id})
	fake.recordInvocation("RetrieveInstanceDetails", []interface{}{id})
	fake.retrieveInstanceDetailsMutex.Unlock()
	if fake.RetrieveInstanceDetailsStub != nil {
		return fake.RetrieveInstanceDetailsStub(id)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.retrieveInstanceDetailsReturns.result1, fake.retrieveInstanceDetailsReturns.result2
}

func (fake *FakeStore) RetrieveInstanceDetailsCallCount() int {
	fake.retrieveInstanceDetailsMutex.RLock()
	defer fake.retrieveInstanceDetailsMutex.RUnlock()
	return len(fake.retrieveInstanceDetailsArgsForCall)
}

func (fake *FakeStore) RetrieveInstanceDetailsArgsForCall(i int) string {
	fake.retrieveInstanceDetailsMutex.RLock()
	defer fake.retrieveInstanceDetailsMutex.RUnlock()
	return fake.retrieveInstanceDetailsArgsForCall[i].id
}

func (fake *FakeStore) RetrieveInstanceDetailsReturns(result1 brokerstore.ServiceInstance, result2 error) {
	fake.RetrieveInstanceDetailsStub = nil
	fake.retrieveInstanceDetailsReturns = struct {
		result1 brokerstore.ServiceInstance
		result2 error
	}{result1, result2}
}

func (fake *FakeStore) RetrieveInstanceDetailsReturnsOnCall(i int, result1 brokerstore.ServiceInstance, result2 error) {
	fake.RetrieveInstanceDetailsStub = nil
	if fake.retrieveInstanceDetailsReturnsOnCall == nil {
		fake.retrieveInstanceDetailsReturnsOnCall = make(map[int]struct {
			result1 brokerstore.ServiceInstance
			result2 error
		})
	}
	fake.retrieveInstanceDetailsReturnsOnCall[i] = struct {
		result1 brokerstore.ServiceInstance
		result2 error
	}{result1, result2}
}

func (fake *FakeStore) RetrieveBindingDetails(id string) (brokerapi.BindDetails, error) {
	fake.retrieveBindingDetailsMutex.Lock()
	ret, specificReturn := fake.retrieveBindingDetailsReturnsOnCall[len(fake.retrieveBindingDetailsArgsForCall)]
	fake.retrieveBindingDetailsArgsForCall = append(fake.retrieveBindingDetailsArgsForCall, struct {
		id string
	}{id})
	fake.recordInvocation("RetrieveBindingDetails", []interface{}{id})
	fake.retrieveBindingDetailsMutex.Unlock()
	if fake.RetrieveBindingDetailsStub != nil {
		return fake.RetrieveBindingDetailsStub(id)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.retrieveBindingDetailsReturns.result1, fake.retrieveBindingDetailsReturns.result2
}

func (fake *FakeStore) RetrieveBindingDetailsCallCount() int {
	fake.retrieveBindingDetailsMutex.RLock()
	defer fake.retrieveBindingDetailsMutex.RUnlock()
	return len(fake.retrieveBindingDetailsArgsForCall)
}

func (fake *FakeStore) RetrieveBindingDetailsArgsForCall(i int) string {
	fake.retrieveBindingDetailsMutex.RLock()
	defer fake.retrieveBindingDetailsMutex.RUnlock()
	return fake.retrieveBindingDetailsArgsForCall[i].id
}

func (fake *FakeStore) RetrieveBindingDetailsReturns(result1 brokerapi.BindDetails, result2 error) {
	fake.RetrieveBindingDetailsStub = nil
	fake.retrieveBindingDetailsReturns = struct {
		result1 brokerapi.BindDetails
		result2 error
	}{result1, result2}
}

func (fake *FakeStore) RetrieveBindingDetailsReturnsOnCall(i int, result1 brokerapi.BindDetails, result2 error) {
	fake.RetrieveBindingDetailsStub = nil
	if fake.retrieveBindingDetailsReturnsOnCall == nil {
		fake.retrieveBindingDetailsReturnsOnCall = make(map[int]struct {
			result1 brokerapi.BindDetails
			result2 error
		})
	}
	fake.retrieveBindingDetailsReturnsOnCall[i] = struct {
		result1 brokerapi.BindDetails
		result2 error
	}{result1, result2}
}

func (fake *FakeStore) RetrieveAllInstanceDetails() (map[string]brokerstore.ServiceInstance, error) {
	fake.retrieveAllInstanceDetailsMutex.Lock()
	ret, specificReturn := fake.retrieveAllInstanceDetailsReturnsOnCall[len(fake.retrieveAllInstanceDetailsArgsForCall)]
	fake.retrieveAllInstanceDetailsArgsForCall = append(fake.retrieveAllInstanceDetailsArgsForCall, struct{}{})
	fake.recordInvocation("RetrieveAllInstanceDetails", []interface{}{})
	fake.retrieveAllInstanceDetailsMutex.Unlock()
	if fake.RetrieveAllInstanceDetailsStub != nil {
		return fake.RetrieveAllInstanceDetailsStub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.retrieveAllInstanceDetailsReturns.result1, fake.retrieveAllInstanceDetailsReturns.result2
}

func (fake *FakeStore) RetrieveAllInstanceDetailsCallCount() int {
	fake.retrieveAllInstanceDetailsMutex.RLock()
	defer fake.retrieveAllInstanceDetailsMutex.RUnlock()
	return len(fake.retrieveAllInstanceDetailsArgsForCall)
}

func (fake *FakeStore) RetrieveAllInstanceDetailsReturns(result1 map[string]brokerstore.ServiceInstance, result2 error) {
	fake.RetrieveAllInstanceDetailsStub = nil
	fake.retrieveAllInstanceDetailsReturns = struct {
		result1 map[string]brokerstore.ServiceInstance
		result2 error
	}{result1, result2}
}

func (fake *FakeStore) RetrieveAllInstanceDetailsReturnsOnCall(i int, result1 map[string]brokerstore.ServiceInstance, result2 error) {
	fake.RetrieveAllInstanceDetailsStub = nil
	if fake.retrieveAllInstanceDetailsReturnsOnCall == nil {
		fake.retrieveAllInstanceDetailsReturnsOnCall = make(map[int]struct {
			result1 map[string]brokerstore.ServiceInstance
			result2 error
		})
	}
	fake.retrieveAllInstanceDetailsReturnsOnCall[i] = struct {
		result1 map[string]brokerstore.ServiceInstance
		result2 error
	}{result1, result2}
}

func (fake *FakeStore) RetrieveAllBindingDetails() (map[string]brokerapi.BindDetails, error) {
	fake.retrieveAllBindingDetailsMutex.Lock()
	ret, specificReturn := fake.retrieveAllBindingDetailsReturnsOnCall[len(fake.retrieveAllBindingDetailsArgsForCall)]
	fake.retrieveAllBindingDetailsArgsForCall = append(fake.retrieveAllBindingDetailsArgsForCall, struct{}{})
	fake.recordInvocation("RetrieveAllBindingDetails", []interface{}{})
	fake.retrieveAllBindingDetailsMutex.Unlock()
	if fake.RetrieveAllBindingDetailsStub != nil {
		return fake.RetrieveAllBindingDetailsStub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.retrieveAllBindingDetailsReturns.result1, fake.retrieveAllBindingDetailsReturns.result2
}

func (fake *FakeStore) RetrieveAllBindingDetailsCallCount() int {
	fake.retrieveAllBindingDetailsMutex.RLock()
	defer fake.retrieveAllBindingDetailsMutex.RUnlock()
	return len(fake.retrieveAllBindingDetailsArgsForCall)
}

func (fake *FakeStore) RetrieveAllBindingDetailsReturns(result1 map[string]brokerapi.BindDetails, result2 error) {
	fake.RetrieveAllBindingDetailsStub = nil
	fake.retrieveAllBindingDetailsReturns = struct {
		result1 map[string]brokerapi.BindDetails
		result2 error
	}{result1, result2}
}

func (fake *FakeStore) RetrieveAllBindingDetailsReturnsOnCall(i int, result1 map[string]brokerapi.BindDetails, result2 error) {
	fake.RetrieveAllBindingDetailsStub = nil
	if fake.retrieveAllBindingDetailsReturnsOnCall == nil {
		fake.retrieveAllBindingDetailsReturnsOnCall = make(map[int]struct {
			result1 map[string]brokerapi.BindDetails
			result2 error
		})
	}
	fake.retrieveAllBindingDetailsReturnsOnCall[i] = struct {
		result1 map[string]brokerapi.BindDetails
		result2 error
	}{result1, result2}
}

func (fake *FakeStore) CreateInstanceDetails(id string, details brokerstore.ServiceInstance) error {
	fake.createInstanceDetailsMutex.Lock()
	ret, specificReturn := fake.createInstanceDetailsReturnsOnCall[len(fake.createInstanceDetailsArgsForCall)]
	fake.createInstanceDetailsArgsForCall = append(fake.createInstanceDetailsArgsForCall, struct {
		id      string
		details brokerstore.ServiceInstance
	}{id, details})
	fake.recordInvocation("CreateInstanceDetails", []interface{}{id, details})
	fake.createInstanceDetailsMutex.Unlock()
	if fake.CreateInstanceDetailsStub != nil {
		return fake.CreateInstanceDetailsStub(id, details)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.createInstanceDetailsReturns.result1
}

func (fake *FakeStore) CreateInstanceDetailsCallCount() int {
	fake.createInstanceDetailsMutex.RLock()
	defer fake.createInstanceDetailsMutex.RUnlock()
	return len(fake.createInstanceDetailsArgsForCall)
}

func (fake *FakeStore) CreateInstanceDetailsArgsForCall(i int) (string, brokerstore.ServiceInstance) {
	fake.createInstanceDetailsMutex.RLock()
	defer fake.createInstanceDetailsMutex.RUnlock()
	return fake.createInstanceDetailsArgsForCall[i].id, fake.createInstanceDetailsArgsForCall[i].details
}

func (fake *FakeStore) CreateInstanceDetailsReturns(result1 error) {
	fake.CreateInstanceDetailsStub = nil
	fake.createInstanceDetailsReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeStore) CreateInstanceDetailsReturnsOnCall(i int, result1 error) {
	fake.CreateInstanceDetailsStub = nil
	if fake.createInstanceDetailsReturnsOnCall == nil {
		fake.createInstanceDetailsReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.createInstanceDetailsReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeStore) CreateBindingDetails(id string, details brokerapi.BindDetails) error {
	fake.createBindingDetailsMutex.Lock()
	ret, specificReturn := fake.createBindingDetailsReturnsOnCall[len(fake.createBindingDetailsArgsForCall)]
	fake.createBindingDetailsArgsForCall = append(fake.createBindingDetailsArgsForCall, struct {
		id      string
		details brokerapi.BindDetails
	}{id, details})
	fake.recordInvocation("CreateBindingDetails", []interface{}{id, details})
	fake.createBindingDetailsMutex.Unlock()
	if fake.CreateBindingDetailsStub != nil {
		return fake.CreateBindingDetailsStub(id, details)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.createBindingDetailsReturns.result1
}

func (fake *FakeStore) CreateBindingDetailsCallCount() int {
	fake.createBindingDetailsMutex.RLock()
	defer fake.createBindingDetailsMutex.RUnlock()
	return len(fake.createBindingDetailsArgsForCall)
}

func (fake *FakeStore) CreateBindingDetailsArgsForCall(i int) (string, brokerapi.BindDetails) {
	fake.createBindingDetailsMutex.RLock()
	defer fake.createBindingDetailsMutex.RUnlock()
	return fake.createBindingDetailsArgsForCall[i].id, fake.createBindingDetailsArgsForCall[i].details
}

func (fake *FakeStore) CreateBindingDetailsReturns(result1 error) {
	fake.CreateBindingDetailsStub = nil
	fake.createBindingDetailsReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeStore) CreateBindingDetailsReturnsOnCall(i int, result1 error) {
	fake.CreateBindingDetailsStub = nil
	if fake.createBindingDetailsReturnsOnCall == nil {
		fake.createBindingDetailsReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.createBindingDetailsReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeStore) DeleteInstanceDetails(id string) error {
	fake.deleteInstanceDetailsMutex.Lock()
	ret, specificReturn := fake.deleteInstanceDetailsReturnsOnCall[len(fake.deleteInstanceDetailsArgsForCall)]
	fake.deleteInstanceDetailsArgsForCall = append(fake.deleteInstanceDetailsArgsForCall, struct {
		id string
	}{id})
	fake.recordInvocation("DeleteInstanceDetails", []interface{}{id})
	fake.deleteInstanceDetailsMutex.Unlock()
	if fake.DeleteInstanceDetailsStub != nil {
		return fake.DeleteInstanceDetailsStub(id)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.deleteInstanceDetailsReturns.result1
}

func (fake *FakeStore) DeleteInstanceDetailsCallCount() int {
	fake.deleteInstanceDetailsMutex.RLock()
	defer fake.deleteInstanceDetailsMutex.RUnlock()
	return len(fake.deleteInstanceDetailsArgsForCall)
}

func (fake *FakeStore) DeleteInstanceDetailsArgsForCall(i int) string {
	fake.deleteInstanceDetailsMutex.RLock()
	defer fake.deleteInstanceDetailsMutex.RUnlock()
	return fake.deleteInstanceDetailsArgsForCall[i].id
}

func (fake *FakeStore) DeleteInstanceDetailsReturns(result1 error) {
	fake.DeleteInstanceDetailsStub = nil
	fake.deleteInstanceDetailsReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeStore) DeleteInstanceDetailsReturnsOnCall(i int, result1 error) {
	fake.DeleteInstanceDetailsStub = nil
	if fake.deleteInstanceDetailsReturnsOnCall == nil {
		fake.deleteInstanceDetailsReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.deleteInstanceDetailsReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeStore) DeleteBindingDetails(id string) error {
	fake.deleteBindingDetailsMutex.Lock()
	ret, specificReturn := fake.deleteBindingDetailsReturnsOnCall[len(fake.deleteBindingDetailsArgsForCall)]
	fake.deleteBindingDetailsArgsForCall = append(fake.deleteBindingDetailsArgsForCall, struct {
		id string
	}{id})
	fake.recordInvocation("DeleteBindingDetails", []interface{}{id})
	fake.deleteBindingDetailsMutex.Unlock()
	if fake.DeleteBindingDetailsStub != nil {
		return fake.DeleteBindingDetailsStub(id)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.deleteBindingDetailsReturns.result1
}

func (fake *FakeStore) DeleteBindingDetailsCallCount() int {
	fake.deleteBindingDetailsMutex.RLock()
	defer fake.deleteBindingDetailsMutex.RUnlock()
	return len(fake.deleteBindingDetailsArgsForCall)
}

func (fake *FakeStore) DeleteBindingDetailsArgsForCall(i int) string {
	fake.deleteBindingDetailsMutex.RLock()
	defer fake.deleteBindingDetailsMutex.RUnlock()
	return fake.deleteBindingDetailsArgsForCall[i].id
}

func (fake *FakeStore) DeleteBindingDetailsReturns(result1 error) {
	fake.DeleteBindingDetailsStub = nil
	fake.deleteBindingDetailsReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeStore) DeleteBindingDetailsReturnsOnCall(i int, result1 error) {
	fake.DeleteBindingDetailsStub = nil
	if fake.deleteBindingDetailsReturnsOnCall == nil {
		fake.deleteBindingDetailsReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.deleteBindingDetailsReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeStore) IsInstanceConflict(id string, details brokerstore.ServiceInstance) bool {
	fake.isInstanceConflictMutex.Lock()
	ret, specificReturn := fake.isInstanceConflictReturnsOnCall[len(fake.isInstanceConflictArgsForCall)]
	fake.isInstanceConflictArgsForCall = append(fake.isInstanceConflictArgsForCall, struct {
		id      string
		details brokerstore.ServiceInstance
	}{id, details})
	fake.recordInvocation("IsInstanceConflict", []interface{}{id, details})
	fake.isInstanceConflictMutex.Unlock()
	if fake.IsInstanceConflictStub != nil {
		return fake.IsInstanceConflictStub(id, details)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.isInstanceConflictReturns.result1
}

func (fake *FakeStore) IsInstanceConflictCallCount() int {
	fake.isInstanceConflictMutex.RLock()
	defer fake.isInstanceConflictMutex.RUnlock()
	return len(fake.isInstanceConflictArgsForCall)
}

func (fake *FakeStore) IsInstanceConflictArgsForCall(i int) (string, brokerstore.ServiceInstance) {
	fake.isInstanceConflictMutex.RLock()
	defer fake.isInstanceConflictMutex.RUnlock()
	return fake.isInstanceConflictArgsForCall[i].id, fake.isInstanceConflictArgsForCall[i].details
}

func (fake *FakeStore) IsInstanceConflictReturns(result1 bool) {
	fake.IsInstanceConflictStub = nil
	fake.isInstanceConflictReturns = struct {
		result1 bool
	}{result1}
}

func (fake *FakeStore) IsInstanceConflictReturnsOnCall(i int, result1 bool) {
	fake.IsInstanceConflictStub = nil
	if fake.isInstanceConflictReturnsOnCall == nil {
		fake.isInstanceConflictReturnsOnCall = make(map[int]struct {
			result1 bool
		})
	}
	fake.isInstanceConflictReturnsOnCall[i] = struct {
		result1 bool
	}{result1}
}

func (fake *FakeStore) IsBindingConflict(id string, details brokerapi.BindDetails) bool {
	fake.isBindingConflictMutex.Lock()
	ret, specificReturn := fake.isBindingConflictReturnsOnCall[len(fake.isBindingConflictArgsForCall)]
	fake.isBindingConflictArgsForCall = append(fake.isBindingConflictArgsForCall, struct {
		id      string
		details brokerapi.BindDetails
	}{id, details})
	fake.recordInvocation("IsBindingConflict", []interface{}{id, details})
	fake.isBindingConflictMutex.Unlock()
	if fake.IsBindingConflictStub != nil {
		return fake.IsBindingConflictStub(id, details)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.isBindingConflictReturns.result1
}

func (fake *FakeStore) IsBindingConflictCallCount() int {
	fake.isBindingConflictMutex.RLock()
	defer fake.isBindingConflictMutex.RUnlock()
	return len(fake.isBindingConflictArgsForCall)
}

func (fake *FakeStore) IsBindingConflictArgsForCall(i int) (string, brokerapi.BindDetails) {
	fake.isBindingConflictMutex.RLock()
	defer fake.isBindingConflictMutex.RUnlock()
	return fake.isBindingConflictArgsForCall[i].id, fake.isBindingConflictArgsForCall[i].details
}

func (fake *FakeStore) IsBindingConflictReturns(result1 bool) {
	fake.IsBindingConflictStub = nil
	fake.isBindingConflictReturns = struct {
		result1 bool
	}{result1}
}

func (fake *FakeStore) IsBindingConflictReturnsOnCall(i int, result1 bool) {
	fake.IsBindingConflictStub = nil
	if fake.isBindingConflictReturnsOnCall == nil {
		fake.isBindingConflictReturnsOnCall = make(map[int]struct {
			result1 bool
		})
	}
	fake.isBindingConflictReturnsOnCall[i] = struct {
		result1 bool
	}{result1}
}

func (fake *FakeStore) Restore(logger lager.Logger) error {
	fake.restoreMutex.Lock()
	ret, specificReturn := fake.restoreReturnsOnCall[len(fake.restoreArgsForCall)]
	fake.restoreArgsForCall = append(fake.restoreArgsForCall, struct {
		logger lager.Logger
	}{logger})
	fake.recordInvocation("Restore", []interface{}{logger})
	fake.restoreMutex.Unlock()
	if fake.RestoreStub != nil {
		return fake.RestoreStub(logger)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.restoreReturns.result1
}

func (fake *FakeStore) RestoreCallCount() int {
	fake.restoreMutex.RLock()
	defer fake.restoreMutex.RUnlock()
	return len(fake.restoreArgsForCall)
}

func (fake *FakeStore) RestoreArgsForCall(i int) lager.Logger {
	fake.restoreMutex.RLock()
	defer fake.restoreMutex.RUnlock()
	return fake.restoreArgsForCall[i].logger
}

func (fake *FakeStore) RestoreReturns(result1 error) {
	fake.RestoreStub = nil
	fake.restoreReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeStore) RestoreReturnsOnCall(i int, result1 error) {
	fake.RestoreStub = nil
	if fake.restoreReturnsOnCall == nil {
		fake.restoreReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.restoreReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeStore) Save(logger lager.Logger) error {
	fake.saveMutex.Lock()
	ret, specificReturn := fake.saveReturnsOnCall[len(fake.saveArgsForCall)]
	fake.saveArgsForCall = append(fake.saveArgsForCall, struct {
		logger lager.Logger
	}{logger})
	fake.recordInvocation("Save", []interface{}{logger})
	fake.saveMutex.Unlock()
	if fake.SaveStub != nil {
		return fake.SaveStub(logger)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.saveReturns.result1
}

func (fake *FakeStore) SaveCallCount() int {
	fake.saveMutex.RLock()
	defer fake.saveMutex.RUnlock()
	return len(fake.saveArgsForCall)
}

func (fake *FakeStore) SaveArgsForCall(i int) lager.Logger {
	fake.saveMutex.RLock()
	defer fake.saveMutex.RUnlock()
	return fake.saveArgsForCall[i].logger
}

func (fake *FakeStore) SaveReturns(result1 error) {
	fake.SaveStub = nil
	fake.saveReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeStore) SaveReturnsOnCall(i int, result1 error) {
	fake.SaveStub = nil
	if fake.saveReturnsOnCall == nil {
		fake.saveReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.saveReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeStore) Cleanup() error {
	fake.cleanupMutex.Lock()
	ret, specificReturn := fake.cleanupReturnsOnCall[len(fake.cleanupArgsForCall)]
	fake.cleanupArgsForCall = append(fake.cleanupArgsForCall, struct{}{})
	fake.recordInvocation("Cleanup", []interface{}{})
	fake.cleanupMutex.Unlock()
	if fake.CleanupStub != nil {
		return fake.CleanupStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.cleanupReturns.result1
}

func (fake *FakeStore) CleanupCallCount() int {
	fake.cleanupMutex.RLock()
	defer fake.cleanupMutex.RUnlock()
	return len(fake.cleanupArgsForCall)
}

func (fake *FakeStore) CleanupReturns(result1 error) {
	fake.CleanupStub = nil
	fake.cleanupReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeStore) CleanupReturnsOnCall(i int, result1 error) {
	fake.CleanupStub = nil
	if fake.cleanupReturnsOnCall == nil {
		fake.cleanupReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.cleanupReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeStore) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.retrieveInstanceDetailsMutex.RLock()
	defer fake.retrieveInstanceDetailsMutex.RUnlock()
	fake.retrieveBindingDetailsMutex.RLock()
	defer fake.retrieveBindingDetailsMutex.RUnlock()
	fake.retrieveAllInstanceDetailsMutex.RLock()
	defer fake.retrieveAllInstanceDetailsMutex.RUnlock()
	fake.retrieveAllBindingDetailsMutex.RLock()
	defer fake.retrieveAllBindingDetailsMutex.RUnlock()
	fake.createInstanceDetailsMutex.RLock()
	defer fake.createInstanceDetailsMutex.RUnlock()
	fake.createBindingDetailsMutex.RLock()
	defer fake.createBindingDetailsMutex.RUnlock()
	fake.deleteInstanceDetailsMutex.RLock()
	defer fake.deleteInstanceDetailsMutex.RUnlock()
	fake.deleteBindingDetailsMutex.RLock()
	defer fake.deleteBindingDetailsMutex.RUnlock()
	fake.isInstanceConflictMutex.RLock()
	defer fake.isInstanceConflictMutex.RUnlock()
	fake.isBindingConflictMutex.RLock()
	defer fake.isBindingConflictMutex.RUnlock()
	fake.restoreMutex.RLock()
	defer fake.restoreMutex.RUnlock()
	fake.saveMutex.RLock()
	defer fake.saveMutex.RUnlock()
	fake.cleanupMutex.RLock()
	defer fake.cleanupMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeStore) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ brokerstore.Store = new(FakeStore)
